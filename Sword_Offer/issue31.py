# -*- coding:utf-8 -*-

# 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？
# 为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,
# 但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,
# 可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。

# 输入：一个整数区间
# 输出：该区间内所有整数的具有的1的次数

# 考察：排列组合问题，归纳法
# 对某一个范围内的数字，分别计算每个位为1的次数，然后加上所有位1出现的次数
# 对个位：它出现的次数：最大数max是10的倍数和个位上的数字a决定：time = （max/10 + (a >=2? 1: 0)） * 1 + （a == 1? 1:0)，
# 如果个位的数字为1，那还要加1；
# 例如：就好像21，它是10的2两倍，所以1可以在0~10出现一次，在10~20出现一次，同时a=1 不大于等于2，所以加上0；
# 因此个位出现的次数是2；

# 对十位：它出现的次数：最大数max是100的倍数和十位上的数字a决定time = (max/100 + (a >=2? 1: 0)) *10，
# 若当前位的数字为1，则它还可加个位上的数字+1次1，因此time = (max/100 + (a >=2? 1: 0))*10  + (max%10 + 1)；
# 例如：就好像1000:，它是100的10倍，所以十位上的1可以在0~100,100~200,...,900~1000出现,对每个区间都可以出现10次，也就是共100次，
# 同时a=0 不大于等于2，所以加上0；如a = 1,则1还可以出现max%10 + 1次
# 对百分位：它出现的次数：最大数max是1000的倍数和百位上的数字a决定：time = max/10 + (a >=2? 1: 0)；

# 实现：从个位1出现次数开始，n除以10计算个位1出现的次数，在除以10计算十位上1出现的次数，依次类推，指导n为零；并求和
# 针对每个位的数字a考虑三种情况：①a=0;②a=1;③a>=2
# 其它位是同样的规律
class Solution:
    def NumberOf1Between1AndN_Solution(self, n):
        # write code here
        temp = n
        bit = 0
        sum = 0
        while(temp):
            remainder = temp % 10
            temp = temp // 10
            plus = temp  #当前位的数字为0
            if remainder > 1: #当前位的数字大于等于2
                plus +=1
            sum = sum + 10**bit * plus  #对当前位的数字为0或者大于等于2
            if remainder == 1: # 当前位的数字为1
                one_plus = n%10**bit + 1
                sum = sum + one_plus
            bit +=1 #进位
        return  sum

# 测试
n = 11
s = Solution()
sum = s.NumberOf1Between1AndN_Solution(n)
print(sum)