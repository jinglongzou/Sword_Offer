# -*- coding:utf-8 -*-

# HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。
# 今天测试组开完会后,他又发话了:在古老的一维模式识别中,
# 常常需要计算连续子向量的最大和,当向量全为正数的时候,
# 问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,
# 并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},
# 连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，
# 返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)

# 输入：一个序列：
# 输出：连续子向量的最大和；也就是求子序列的最大和问题
# 考察动态规划算法：
# 首先找到最优子结构：如果序列a[j]是具有最大和的连续子序列的末尾元素，那么可以分两种情况来考虑：
# ①这个连续子序列只有一个元素，那么最大和就是该元素a[j]；②这个连续子序列有多个元素,假定为序列为a[i:j]，
# 所以最大和是：a[i:j-1] + a[j]；
# 这也就是说对以某个元素结尾的的最长连续子序列，可以分为两种种情况，只有它的子序列和没它的子序列；
# 将一个元素与它前的一段子序列的和B加上它作比较；
# 如果sum = max(a[i],B+a[i],B);如果是a[i],则最长子序列的起点改为i,否则最长子序列的终点加1，直到遍历完所有的数字
# ②重复子结构：不同的连续子序列可能具有相同最大和的相同最长连续子序列的
# 因此需要辅助变量：最长子序列起点，最长子序列终点，最长子序列的和；

# 特别注意动态规划相比分治法的一个优势，就是能够避免大量重复的计算，
# 而这是通过记录每个子问题的最优子结构来实现，不同的子问题具有相同的最优子结构，
# 因此解也就一样，直接对新子问题查询最优子结构的解即可。

# 因此求出每一个节点的最大和的最长子序列
# 那么这是一个动态规划问题
class Solution:
    def FindGreatestSumOfSubArray(self, array):
        # write code here
        n = len(array)
        if n == 0:
            return 0
        if n == 1:
            return array[0]
        temp = array[0]
        start = 0
        end = 0
        dp =[]
        dp.append([temp,start,end])
        sum = dp[0]
        for i in range(1,n):
            # 求以每个元素结尾的连续子序列的最大和
            start = dp[i-1][1]
            end = dp[i-1][2]
            temp = dp[i-1][0] + array[i]
            if temp < array[i]:
                temp = array[i]
                start = i
                end = i
                dp.append([temp, start, end])
            else:
                end = i
                dp.append([temp, start, end])
            if dp[i][0]>sum[0]:
                sum = dp[i]

        return sum

# 测试
L = [6,-3,-2,7,-15,1,15,-2]
s = Solution()
print(s.FindGreatestSumOfSubArray(L))
